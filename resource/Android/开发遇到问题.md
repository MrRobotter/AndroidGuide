### 解决安卓开发静态变量被系统回收的问题
开发中我们也许会用到全局静态变量，方便在不同的界面和类中使用，然而，这样会出现一个致命的问题：
静态变量会被系统回收。举个例子，我们在启动页获取屏幕的宽高，
把他定义在LoadingActivity的一个静态成员变量

````java
public class LoadingActivity exends AppCompatActivity{]

    public static int screenWidth;

    onCreate(){
    }

}
````

然后这个screenWidth肯会被某个类使用，现在我们按Home键去玩一把游戏，一段时间之后，
我们再次回到我们的APP界面，但是在玩游戏的过程中，由于内存紧张，我们的screenWidth被系统回收了，变成了默认值0，
如果有初始化赋值，则为初始化值，如对象则为null。

    举个栗子：一个安卓应用A先后打开了3个Activity：a->b->c
    这个时候，如果来了个电话，我们接听电话的过程中，手机内存不够，那么应用A就会被系统回收
    当打完电话，再次进入应用A的时候会发生下面的事情：

     1. 系统重新加载c，而且在新的线程中
     2. 现在点返回关闭c,系统就会重新加载b，而且是在新的线程中（跟c不是一个线程）
     3. 再次点击返回关闭b，系统会重新加载a，而且是在新的线程中，（跟c，b的线程都不相同）
     （就是先打开c，finish了c时加载b，finish了b时加载a）
 **注意**这个时候应用中的全局静态变量将全部重置（有默认值的为默认值，没有默认值为null）
 这样就获取了错误的数据

### 解决办法

 * 方法一：

 * 二：
 * 三：
 * 四：

### Activity回收检测


### Gradle中 `compile`和`implementation` 各是什么含义？
* `compile` 编译；编制；汇编；编辑  记忆技巧：com 共同 + pil 柱，堆；堆积 + e →〔将材料〕堆在一起 → 编纂
* `implementation` 履行;实施 【计算机】类的实现；工具;器具;用具 
    
    2017年google发布AS 3.0之后，`com.android.tools.build:gradle`工具也升级到了3.0.0，在3.0.0中使用了最新的Gradle4.0里程碑版本作为gradle的编译工具，该版本gradle编译速度有所提升，完全支持java8，以及Kotlin的支持更加完美，Kotlin插件默认安装。

* AS 3.0中 `compile` 依赖关系已经被弃用，被implementation和api替代 provided被compile only替代，apk被 runtime only替代。

**api:** 和2.x版本的 `compile` 完全相同.

**implementation:** 使用了该命令编译的依赖，它仅仅对当前的Moudle提供接口。例如当前的项目结构:
````
                App Module
                     |
            _________________
            |               |           
        LibraryA        LibraryC  
            |               |
        LibraryB        LibraryD

````
LibraryA中引用了LibraryB的库，如果对LibraryB的依赖使用的是`implementation`关键字。如下：
````
 dependencies{
 ......
 implementation project(path:`: LibraryB`)
 }
````
那么 LibraryB 中的接口只能给LibraryA使用，而我们的App Moudle是无法访问到LibraryC提供的接口的，
也就是将依赖隐藏在内部，而不对外部公开。这就是`implementation`关键字的作用。

* 建议
    在Google IO相关话题中提到了一个建议，就是首先应该设置为implementation的，如果没有错就用 implementation 
    如果有错就使用api指令，这样会使编译速度有所增快。
* 这样做的好处
    * 加快编译速度。
    * 隐藏对外不必要的接口。

* 为什么能加快编译速度呢？
    这对于大型项目含有多个Moudle的模块，如上面的项目结构，比如我们改动LibraryB接口的相关代码，
    这个时候编译只需要单独编译LibraryA模块就行，如果使用的是`api`或者`compile`，由于App Moudle也可以访问到LibraryB
    所以在全编译的情况下，App Moudle 也需要重新编译。

* compile(api)
    这种是我们之前常用的方式，使用该方式依赖的库将参与 **编译**和**打包**。
    当我们依赖一些第三方的库时，可能会遇到`com.android.support`冲突问题，就是因为开发者使用的是`compile`依赖的`com.android.support`
    包，他依赖的包与我们本地依赖的`com.android.support`版本不一样，所以会报以下错误
````
All com.android.support libraries must use the exact same version specification (mixing versions can lead to runtime crashes)
````

### POS机项目开发
* 文件资源找不到
* 数据加载完毕判断、空值判断！

### MagicIndicator
一个强大的、可定制、易扩展的ViewPager指示器框架[查看原文](https://github.com/hackware1993/MagicIndicator)

